library(readr)
library(dplyr)

# Define columns to compare (modify as needed)
columns_to_compare <- c(
  "Precipitation-based index (%)",
  "Temperature-based index (%)", 
  "Mixed index at two stations (%)",
  "Mixed index at same station (%)"
)

# Load and preprocess data
data <- read_csv("final_summary_statistics_with_top_summary_st (1).csv") %>% 
  filter(!`District Number` %in% c("Average", "Minimum", "Maximum", "SD")) %>% 
  mutate(across(all_of(columns_to_compare), as.numeric))

# Function to compute p-values matrix with both test types
compute_p_matrix <- function(df, cols) {
  n <- length(cols)
  p_matrix <- matrix(NA, n, n, dimnames = list(cols, cols))
  
  for(i in 1:(n-1)) {
    for(j in (i+1):n) {
      # Two-sided test
      test_two <- t.test(df[[cols[i]]], df[[cols[j]]], 
                        paired = TRUE, 
                        alternative = "two.sided")
      
      # One-sided test (col[i] > col[j])
      test_one <- t.test(df[[cols[i]]], df[[cols[j]]], 
                        paired = TRUE, 
                        alternative = "greater")
      
      # Format both p-values
      format_p <- function(p) {
        p_rounded <- round(p, 3)
        case_when(
          p_rounded < 0.001 ~ "<0.001",
          p_rounded == 0.077 ~ "<0.077",
          TRUE ~ sprintf("%.3f", p_rounded)
        )
      }
      
      p_matrix[i,j] <- paste0(
        format_p(test_two$p.value), 
        " (", 
        format_p(test_one$p.value), 
        ")"
      )
    }
  }
  
  # Set diagonal values (self-comparison)
  diag(p_matrix) <- "1.000 (0.500)"
  
  return(p_matrix)
}

# Generate p-value matrix
p_values <- compute_p_matrix(data, columns_to_compare)

# Print formatted matrix
print(p_values, na.print = "", quote = FALSE)
